=== Getting Started with Micronaut and Graal

To get started creating a Microservice that can be compiled into a native image, use the `graal-native-image` feature when creating the application with the CLI:

.Creating a Graal Native Microservice
[source,bash]
----
$ mn create-app hello-world --features graal-native-image
----

The `graal-native-image` feature adds four important items:

1. The `svm` and `graal` dependencies to your `build.gradle` (or `pom.xml` if `--build maven` is used).
2. A `Dockerfile` which can be used to construct the native image using Docker and a script `docker-build.sh` to run it.
3. A `build-native-image.sh` script to build the native image without using Docker.


==== Building a Native Image Using Docker

To build your native image using Docker simply run:

[source,bash]
----
$ docker build . -t hello-world
$ docker run --network=host hello-world # <1>
----
<1> Start the Docker container with `--network=host` makes the application uses the same network as the host so all ports are exposed automatically without needing to map them manually

Or use the provided script:

[source,bash]
----
$ ./docker-build.sh
----

The provided `Dockerfile` is a multi-stage dockerfile which builds the project in three steps:

1. A Gradle or Maven image will build the project.
2. A GraalVM official image will build the native image.
3. A typical dockerfile structure will build the final image which in smaller due to layering.

With this approach you need to have installed only Docker as it downloads the required images, if necessary.


==== Building a Native Image Without Using Docker

To build your native image without using Docker you need to install GraalVM SDK via the https://www.graalvm.org/docs/getting-started/[Getting Started] instructions or using SDKman:

.Installing GraalVM 1.0.0-rc13 with SDKman
[source,bash]
----
$ sdk install java 1.0.0-rc-13-grl
$ sdk use java 1.0.0-rc-13-grl
----

.Creating native image
[source,bash]
----
$ ./build-native-image.sh
----


=== Understanding Micronaut and Graal

Micronaut itself does not rely on reflection or dynamic classloading so works automatically with GraalVM native, however certain third party libraries used by Micronaut may require additional input about uses of reflection.

Micronaut includes an annotation processor that helps to handle generating the `reflect.json` metadata:

dependency:micronaut-graal[scope="annotationProcessor"]

This processor will generate a `reflect.json` file to a file called `META-INF/reflect.json` in your build classes directory (`target/classes` with Maven and typically `build/classes/java/main` with Gradle).

TIP: If you wish to provide your own `reflect.json` you can add one to `src/main/graal/reflect.json`.


=== Adding Additional Classes for Reflective Access

To inform Micronaut of additional classes that should be included in the generated `reflect.json` file at compilation time you can either annotate a class with ann:core.annotation.Introspected[] or ann:core.annotation.TypeHint[].

The former will generate a compile time introspection as well as allowing reflective access and the latter will only allow reflective access and is typically used on a module or `Application` class to include classes that are needed reflectively. For example, the following is taken from Micronaut's Jackson module:

[source,java]
----
@TypeHint(
        value = {
                PropertyNamingStrategy.UpperCamelCaseStrategy.class,
                ArrayList.class,
                LinkedHashMap.class,
                HashSet.class
        },
        accessType = TypeHint.AccessType.CLASS_LOADING
)
----

=== Generating Native Images

Once the `reflect.json` file is ready you can run the `native-image` command. The script runs the following `native-image` command:

.The `native-image` command
[source,bash]
----
native-image --no-server \ # <1>
             --class-path build/libs/hello-world-0.1-all.jar \ # <2>
             -H:ReflectionConfigurationFiles=build/classes/java/main/META-INF/reflect.json \ # <3>
             -H:EnableURLProtocols=http \ # <4>
             -H:IncludeResources="logback.xml|application.yml" \ # <5>
             -H:Name=hello-world \ # <6>
             -H:Class=hello.world.Application \ # <7>
             -H:+ReportUnsupportedElementsAtRuntime \ # <8>
             -H:+AllowVMInspection \
             --allow-incomplete-classpath \ # <9>
             --rerun-class-initialization-at-runtime='sun.security.jca.JCAUtil$CachedSecureRandomHolder,javax.net.ssl.SSLContext' \
             --delay-class-initialization-to-runtime=io.netty.handler.codec.http.HttpObjectEncoder,io.netty.handler.codec.http.websocketx.WebSocket00FrameEncoder,io.netty.handler.ssl.util.ThreadLocalInsecureRandom,com.sun.jndi.dns.DnsClient # <10>
----
<1> Do not start a background server to generate the native image
<2> The `class-path` argument is used to refer to the Micronaut shaded JAR
<3> The `-H:ReflectionConfigurationFiles` option points GraalVM to the `reflect.json` file (or files) needed to run the application. Multiple comma-separated files can be specified.
<4> Micronaut uses the JVM's default URL connection classes. The `-H:EnableURLProtocols` allows using them in GraalVM `nativeimage`.
<5> The `-H:IncludeResources` argument specifies a regex to dictate which static resources should be included in the image.
<6> The `-H:Name` argument specifies the name of the native image to be built
<7> The `-H:Class` argument specifies the Java main class that is the entry point of the application.
<8> The `-H:+ReportUnsupportedElementsAtRuntime` tells GraalVM to report any `ClassNotFoundException` errors at runtime instead of at build time.
<9> The `--allow-incomplete-classpath` tells GraalVM to report missing classes only at runtime instead of at native image generation time.
<10> The `--delay-class-initialization-to-runtime` specifies which classes static initializers should be delayed until runtime. GraalVM by default runs static initializers at build time. That is undesirable in certain cases (particularly with Netty).


Once the image has been built you can run the application using the native image name:

.Running the Native Application
[source,bash]
----
$ ./hello-world
15:15:15.153 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 14ms. Server Running: http://localhost:8080
----

As you can see the advantage of having a native image is startup completes in milliseconds and memory consumption does not include the overhead of the JVM (a native Micronaut application runs with just 20mb of memory).
